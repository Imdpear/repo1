#### 索引模块

##### 1.为什么要使用索引

避免全表扫描去查找数据，提升检索效率

##### 2.什么样的信息能成为索引

主键、唯一键等只要能让数据有一定区分性的字段

##### 3.索引的数据结构

主流的是B+树，还有bitmap 、hash 等，mysql不支持bitmap索引

##### 4.密集索引和稀疏索引的区别

a)密集索引文件中的每个搜索码值都对应一个索引值，其叶子节点保存不仅仅是键值，还保存了位于同一行记录里的其他列的信息，由于密集索引决定了表的物理排列顺序，一个表只能有一个物理排列顺序，所以一个表只能创建一个密集索引。
b)稀疏索引文件只为索引码的某些值建立索引项，其叶子节点仅保存了键位信息以及该行数据的地址或者主键。

##### 1、mysql默认引擎

　　mysql-5.1版本之前默认引擎是MyISAM，之后是innoDB

##### 2、关系

　　MyISAM是非集聚引擎，支持全文索引;不支持事务;它是表级锁;会保存表的具体行数.
　　innoDB是集聚引擎，5.6以后才有全文索引;支持事务；它是行级锁;不会保存表的具体行数.

一般：不用事务的时候,count计算多的时候适合myisam引擎。对可靠性要求高就是用innodby引擎。

##### 3、索引分类

1.普通索引index :加速查找
2.唯一索引
主键索引：primary key ：加速查找+约束（不为空且唯一）
唯一索引：unique：加速查找+约束 （唯一）
3.联合索引
-primary key(id,name):联合主键索引
-unique(id,name):联合唯一索引
-index(id,name):联合普通索引
4.全文索引fulltext :用于搜索很长一篇文章的时候，效果最好。
5.空间索引spatial :了解就好，几乎不用



##### 5.慢查询

//查询慢查询参数
show VARIABLES like '%quer%'

//开启慢查询   可以在配置文件设置永久开启
set GLOBAL slow_query_log = on ;

//设置慢查询记录时间 需要重新连接   
set GLOBAL long_query_time = 1 ;

EXPLAIN SELECT menu_name FROM xc_menu ORDER BY menu_name DESC

EXPLAIN SELECT code  FROM xc_menu ORDER BY code DESC

EXPLAIN SELECT count(id) from xc_menu;

//强制选择走的索引

EXPLAIN SELECT count(id) from xc_menu force index(primary);

//添加索引

alter table xc_menu add index idx_name(menu_name)

##### 6.联合索引最左匹配原则

​	mysql会一直向右匹配，知道遇到范围查询>< between like就停止匹配，之前的能用到联合索引

##### 7.索引建的越多越好吗

​	不是，数据量小的表不需要建立索引，增加额外的开销， 数据变更就要维护索引，增加维护成本，更多的索引需要更多的空间



#### 锁模块

##### 1.MyISAM与InnoDB关于锁方面的区别是什么

​	MyISAM默认用的是表级锁，不支持行级锁

​		适用:频繁执行全表count语句，它存储了数据条数

​		查询频繁，增删改查频率不高

​		没有事务

​		当对一张表读的时候，对表加读锁，同时对同一张表增删改操作加写锁，当读锁未被释放的时候，写操作会一直阻塞，直到读锁被释放,反之亦然；如果都是读，则不阻塞，读锁也叫共享锁

​		

​		主动加锁和释放锁

​		lock tables 表名 read/write;

​		unlock tables;

​	InnoDB默认用的是行级锁，也支持表级锁

​		主动加锁 

​		lock in share mode   共享锁

​		lock for update	排它锁

##### 2.数据库事务的四大特性

​	原子性     所有操作要么一起成功，要么一起失败回滚

​        一致性    数据库从一个一致的状态 转变成另一个一致的状态，满足完整性约束   例如转账操作  转账前和转账后钱总数是一致的

​	隔离性   多个事务并发执行时，各个事务之间互不影响

​	持久性  一个事务提交后，对数据库的修改永久保存在数据库上，即使系统故障，之后也能对已经提交的事务进行更新

​       ​	

##### 3.事务隔离级别以及各级别下的并发访问问题

​	1.更新丢失   mysql所有事务隔离级别在数据库层面上均可避免

​		 read-uncommitted（未提交读）事务隔离级别以上可避免

​	2.脏读（一个事务读到了另一个事务还未提交的更新数据）  

​		 read-committed（已提交读）事务隔离级别以上可避免

​	3.不可重复度（一个人事务读取同一条数据结果不一致，因为其他事务在此期间提交执行更新）  

​		repeatable-read（可重复读）事务隔离级别以上可避免

​	4.幻读（事务A读取与搜索条件相匹配的若干行，事务B以插入或修改行方式操作事务A的结果集，事务A更新操作出现处理结果的行数与读取行数不一致）    	

​		SERIALIZABLE（串行化）事务隔离级别可避免

​	

##### 4.InnoDB可重复读隔离级别下如何避免幻读



##### 5.RC、RR级别下的InnoDB的非阻塞读如何实现



##### 6.SQL关键语法

#查询所有同学的学号，选课数，总成绩

select student_id ,count(course_id),sum(score) from score **group by** student_id

#列函数对于group by 子句定义的每个组各返回一个结果

#如果用group by,那么你的select语句中选出的列要么是你group by后面用到的列，要么就是带有sum min等列函#数的列



#查询所有同学的学号、姓名、选课数、总成绩





#### Docker

##### 1.启动

systemctl start docker

##### 2.停止

systemctl stop docker

##### 3.重启

systemctl restart docker

##### 4.开机自启

systemctl enable docker

##### 5.概要信息

docker info

##### 6.帮助文档

docker --help

##### 7.镜像相关命令

查看镜像

docker images

搜索镜像

docker search 镜像名称

拉取镜像

docker pull centos:7（镜像名称）

删除镜像

​	按镜像id删除镜像

​	docker  rmi   镜像ID

删除所有镜像

​	docker rmi  `docker images -q`

##### 8.容器相关命令

查看正在运行的容器

docker  ps

查看所有的容器

docker ps -a

查看最后一次运行的容器

docker ps -l

查看停止的容器

docker ps  -f  status=exited

##### 9.创建与启动容器





SOA 微服务架构













​	

​		

​	